# C++

#### C++三大特性

封装：把客观的事物抽象成一个类（将数据和方法打包在一起，加以权限的区分，达到保护并安全使用数据的目的）
可以把数据创建成私有的，把方法创建成公有的，其他人可以调用公开的方法，但是不能修改私有的数据，可以达到安全管理。

继承：继承所表达的是类之间的相关关系，这种关系使得对象可以继承另一个对象的特征和能力
目的：避免公用代码的重复开发，减少代码的数据冗余。

多态：“提供一个接口，多种方法”字面意思为多种形态。程序在运行时才决定调用的函数，它是面向对象领域的核心概念。

#### 智能指针和普通指针的区别

智能指针的行为类似于常规指针，重要的区别是它负责自动释放所指向的对象

`shared_ptr` 维护一个指向该内存的指针数量，为0时自动销毁内存

`unique_ptr` 某时刻只允许一个`unique_ptr`指向该对象 

`weak_ptr` 指向`shared_ptr`对象，但不增加引用计数

`make_shared`会返回一个智能指针，而new返回的是内置指针。而智能指针构造函数是显式构造，不能隐式转换，必须使用直接初始化形式来初始化智能指针。

```c++
shared_ptr<int> p1(new int(1024)); //正确
shared_ptr<int> p2 = new int(1024); //错误
```

不要将内置指针和智能指针混合使用，也不要用get初始化另一个智能指针

**为什么不再使用`auto_ptr`**

`auto_ptr`在赋值或者拷贝的时候，会将地址转交的同时将原指针置为NULL，会产生不安全行为。因此用`unique_ptr`替换，`unique_ptr`不支持拷贝和赋值，只能调用release成员放弃对指针的控制权。

**`weak_ptr`的使用**

不会影响某个对象的生存周期，但可以阻止用户访问一个不再存在的对象。可用于打破循环引用。

#### 拷贝控制

1. 使用`=default`显示地要求编译器生成默认构造函数和析构函数

2. 使用`=delete`指出我们希望该函数是被删除的，从而阻止默认拷贝构造，但析构函数不能定义为删除

3. 右值引用只能绑定到临时对象：

    1. 所引用的对象将要被销毁

    2. 该对象没有其他用户

        因此，使用右值引用的代码可以自由地接管所引用对象的资源

    move函数可以获得绑定到左值上的右值引用，调用move就意味着承诺:除了对其源变量赋值或者销毁它外，我们将不再使用它，不能对其值做任何假设。

4. 当类没有被自定义拷贝构造函数且可以移动时，编译器也会合成移动构造函数。使用构造函数时，移动右值，拷贝左值

5. 可以通过引用限定符&和&&限制成员函数的调用对象

#### 顺序容器

1. 使用emplace操作:`emplace_front`, `emplace`, `emplace_back`

    传入参数，通过构造函数直接构造相应的结构

2. 通过`.front()`, `.back()`获取容器中首尾元素的引用。`.at()`可以保证不会数组越界，会抛出"out of range"异常

#### new和malloc的区别

1. new操作符动态分配内存，无需指定内存大小。malloc需要显示指出所需内存大小

2. new分配内存成功时，返回的是对象类型的指针，无需类型转换，而malloc则是返回void*

3. new允许重载，malloc则不然

4. new内存分配失败时，会抛出bad_alloc异常。malloc分配内存失败时返回NULL。

5. new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。

    `堆是操作系统维护的一块内存，而自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价。程序员也可以通过重载new操作符，改用其他内存来实现自由存储`


#### c++编译的过程

假设有一个源程序hello.c

1. 预处理阶段：预处理器(cpp)将头文件的内容插入程序文本，得到hello.i文件
2. 编译阶段：编译器(ccl)将文本文件hello.i翻译成汇编语言程序hello.s
3. 汇编阶段：汇编器(as)将hello.s翻译成机器语言指令，打包成**可重定位目标程序**(relocatable object program) hello.o
4. 链接阶段：将可重定位目标文件链接起来通过符号解析和重定位，生成可执行目标文件

#### 虚函数

virtual用于声明虚函数，支持动态多态，子类调用该虚函数使用自己的实现

纯虚函数用`=0`表示，含有纯虚函数的类称为抽象类，其子类必须实现该纯虚函数，抽象类不能实例化

**virtual和overwrite的区别**:

如果子类overwrite了基类的函数，就不能实现多态，只能调用相应对象的函数。不能通过基类指针指向子类的不同实现。

虚函数的实现是建立在虚表上，存在虚函数的类都存在一个一维的虚函数表，类存在一个虚表指针指向虚表。

在构造函数中进行虚表的创建和虚表指针的初始化。

而当一个派生类继承了一个有虚函数的基类时，派生类不会产生新的虚表，而是在原来的虚表上更改，自身与基类虚表中相同的函数会**覆盖**掉虚表中的对应函数，与虚表中不同的虚函数会添加到虚表的**尾部**。

**动态绑定**

有一个基类，两个派生类，基类有一个virtual函数，两个派生类都覆盖了这个虚函数。现在有一个基类的指针或者引用，当该基类指针或者引用指向不同的派生类对象时，调用该虚函数，那么最终调用的是该被指向对象对应的派生类自己实现的虚函数。

#### 指针和引用的区别

1. 指针可以设为NULL，引用必须代表一个对象
2. 指针可以被重新赋值，指向另一个对象，引用总代表最初获得的那个值

#### [虚继承](https://blog.csdn.net/longlovefilm/article/details/80558879?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs&dist_request_id=0f1eb594-7b69-46c4-b10d-7da4d69f4a68&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs)

从不同途径继承来的同一基类，会在子类中存在多份拷贝。这将存在两个问题：其一，浪费存储空间；第二，存在二义性问题，通常可以将派生类对象的地址赋值给基类对象，实现的具体方式是，将基类指针指向继承类（继承类有基类的拷贝）中的基类对象的地址，但是多重继承可能存在一个基类的多份拷贝，这就出现了二义性。

**在间接继承共同基类时只保留一份基类成员**

每个虚继承的子类都有一个虚基类指针，指向虚基类表，表中记录了虚基类与本类的偏移地址。通过偏移地址就能找到虚基类成员。

#### NULL和nullptr的区别

在C中NULL被定义为**#define NULL ((void \*)0)**

但c++中不允许隐式转换void*，因此将NULL定义为0，但这样会导致函数重载时调用int参数的函数：

```c++
using namespace std;
 
void func(void* i)
{
	cout << "func1" << endl;
}
 
void func(int i)
{
	cout << "func2" << endl;
}
 
void main(int argc,char* argv[])
{
	func(NULL);
	func(nullptr);
	getchar();
}

//输出
//func2
//func1
```

我们本想用NULL代替空指针，但却选择了int形参的函数，违背了我们的初衷，因此引入`nullptr`，在此类情况下可以正确调用函数

#### 不能声明为虚函数的函数

**普通函数（非成员函数）**；**静态成员函数**；**内联成员函数**；**构造函数**；**友元函数**。

#### 函数中的参数指针

把一个指针做为参数传一个方法时，其实是把指针的复本传递给了方法，也可以说传递指针是指针的值传递。

如果我们在方法内部修改指针会出现问题，在方法里做修改只是修改的指针的copy而不是指针本身，原来的指针还保留着原来的值。

可以用**指针的指针**或者**指针引用**来修改指针。

#### 类型转换

`static_cast` 用于普通的类型转换，但不能将值转换成指针，也不能去除常量性

`const_cast` 用于改变变量的常量性

`dynamic_cast`用来执行继承中的向子类转型，但无法应用在缺乏虚函数的类型上

`reinterpret_cast`用于函数指针的转型

#### static

静态局部变量：储存在.data段，能在程序存活周期内一直存在，不会消亡

静态全局变量、静态函数：隐藏，将作用域局限于本文件内，在其他文件中即使用`extern`也不能调用

静态成员函数：通过类直接调用，不能调用类的非静态变量，没有this指针

#### pop_back()没有返回值

为了保证异常安全：
一旦发生异常，数据应当恢复到导致发生异常的操作之前的状态。

如果用户在pop时因为某种异常没有接收到返回值，但值在pop中又被删除了，会导致这个数据永久丢失。

同时为了保证一个函数只完成一项特定的功能，使得函数功能之间耦合度降低。

#### 构造函数

构造一个对象的时候分为两个步骤，一是初始化，二是赋值。构造函数在进入函数体之前已经完成了初始化步骤，函数体内部只是一次赋值操作。而通过**构造函数初始化列表**可以直接用想要的值对变量进行初始化，免去了赋值操作。同时如果类中有`const`变量，必须通过初始化列表构造，不能在函数体内赋值。

#### 红黑树和AVL树的区别

红黑树不追求完全的平衡，在插入时两种树的旋转量都是O(1)，而删除时AVL树可能会导致整个子树的旋转，旋转的量级为O(logn)，而红黑树则至多需要三次旋转就能平衡。

AVL的结构相较于RB-Tree更为平衡，插入和删除引起失衡，如2所述，RB-Tree复衡效率更高；当然，由于AVL高度平衡，因此AVL的Search效率更高啦。

针对插入和删除节点导致失衡后的rebalance操作，红黑树能够提供一个比较"便宜"的解决方案，降低开销，是对search，insert ，以及delete效率的折衷，总体来说，RB-Tree的统计性能高于AVL.

故引入RB-Tree是**功能、性能、空间开销的折中结果**。

红黑树的定义

每个节点或是黑色或是红色 
根节点是黑色 
每个叶节点是黑色（叶节点为空节点） 
如果一个节点是红色，则它的子节点必须是黑色 
从一个节点到该节点的所有叶节点的路径包含相同数目的黑色节点