# C++

#### 智能指针和普通指针的区别

智能指针的行为类似于常规指针，重要的区别是它负责自动释放所指向的对象

`shared_ptr` 维护一个指向该内存的指针数量，为0时自动销毁内存

 `unique_ptr` 某时刻值允许一个unique_ptr指向该对象 

`weak_ptr` 指向`shared_ptr`对象，但不增加引用计数

#### 拷贝控制

1. 使用`=default`显示地要求编译器生成默认构造函数和析构函数

2. 使用`=delete`指出我们希望该函数是被删除的，从而阻止默认构造/拷贝，但析构函数不能定义为删除

3. 右值引用只能绑定到临时对象：

    1. 所引用的对象将要被销毁

    2. 该对象没有其他用户

        因此，使用右值引用的代码可以自由地接管所引用对象的资源

    move函数可以获得绑定到左值上的右值引用，调用move就意味着承诺:除了对其源变量赋值或者销毁它外，我们将不再使用它，不能对其值做任何假设。

4. 当类没有被自定义拷贝构造函数且可以移动时，编译器也会合成移动构造函数。使用构造函数时，移动右值，拷贝左值

5. 可以通过引用限定符&和&&限制成员函数的调用对象

#### 顺序容器

1. 使用emplace操作:`emplace_front`, `emplace`, `emplace_back`

    传入参数，通过构造函数直接构造相应的结构

2. 通过`.front()`, `.back()`获取容器中首尾元素的引用。`.at()`可以保证不会数组越界，会抛出"out of range"异常

#### new和malloc的区别

1. new操作符动态分配内存，无需指定内存大小。malloc需要显示指出所需内存大小

2. new分配内存成功时，返回的是对象类型的指针，无需类型转换，而malloc则是返回void*

3. new允许重载，malloc则不然

4. new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。

5. new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。

    `堆是操作系统维护的一块内存，而自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价。程序员也可以通过重载new操作符，改用其他内存来实现自由存储`

    