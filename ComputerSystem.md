# 计算机系统

#### 分布式系统中的CAP理论

一个分布式系统最多只能同时满足一致性(**Consistency**)，可用性(**Availability**)和分区容错性(**Partition tolerance**)这三项中的两项.

1. 一致性

    当多个数据并发读写时，有可能发生一致性问题

    一致性分为三类：

    1. 强一致性：

        要求更新后的数据在各个主机中同时可见

    2. 弱一致性：

        复制是异步的，可以在部分主机访问不到

    3. 最终一致性

        在一段时间后能够访问到更新后的数据

2. 可用性

    在正常响应时间内一直可用，要求分布式数据冗余，负载均衡

3. 分区容错性

    分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性或可用性的服务。

考虑一种极端情况，如果有两台系统A，B共享数据，当A，B的网络连接发生中断，为了满足分区容错性，A，B独立进行工作。当有用户对A中的数据修改时，A、B数据无法同步。此时如果有用户请求B中的数据，如果B响应则违背了一致性，不响应请求，阻塞直到更新数据则违背了可用性。

因此对于舍弃哪一个特性区分出三种情况：

> CA without P：如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但其实分区不是你想不想的问题，而是始终会存在，因此CA的系统更多的是允许分区后各子系统依然保持CA。
> CP without A：如果不要求A（可用），相当于每个请求都需要在Server之间强一致，而P（分区）会导致同步时间无限延长，如此CP也是可以保证的。很多传统的数据库分布式事务都属于这种模式。
> AP wihtout C：要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。现在众多的NoSQL都属于此类。

#### lazy evaluation(缓式评估)

避免非必要的对象复制，避免非必要的数据库读取动作，避免非必要的数值计算，直到这些动作真正被输出或使用

《More Effective C++》item17

#### 原子性(Atomicity)

一个动作要么全部执行，或者不执行。避免动作部分发生造成的问题无法恢复

Commit point

在Commit point之前结束的动作全部撤销，在Commit point之后的动作全部还原

影子分页 日志
