# 操作系统

#### [缺页中断](https://www.cnblogs.com/sunsky303/p/9214223.html)

软件试图访问已映射在虚拟地址空间中，但是目前并未被加载在物理内存中的一个分页时，由中央处理器的内存管理单元所发出的中断。

#### [进程间的通信方式](https://blog.csdn.net/m0_37907797/article/details/103188294)

1. 管道
2. 消息队列
3. 共享内存
4. 信号量
5. Socket

#### 线程的6种状态

1. New
2. Runnable(分为Running和Ready)
3. Blocked(**进入 synchronized 关键字保护的代码，但是没有获取到 monitor 锁**)
4. Waiting
5. Timed Waiting
6. Terminated

**处于 Runnable 状态的线程并不一定在运行**。

**Blocked 在等待其他线程释放 monitor 锁，而 Waiting 则是在等待某个条件，比如 join 的线程执行完毕，或者是 notify ()/notifyAll ()**。

Timed Waiting与 Waiting 状态的区别在于：**有没有时间限制，Timed Waiting 会等待超时，由系统自动唤醒，或者在超时前被唤醒信号唤醒**。

#### 进程和线程有什么区别

1. 进程是内存分配的最小单位，线程是调度的最小单位

2. 进程有自己的独立地址空间，而线程则是共享本线程的数据空间。因此CPU切换和创建一个线程的花费远小于进程

3. 进程切换比线程切换慢的原因在于，进程切换后地址空间发生改变，会导致TLB失效，需要从页表中读取数据使得程序运行缓慢

    *优化方案是： 增加硬件支持，实现跨上下文切换的TLB共享， 例如在TLB表项中添加进程标识符，区分不同进程*

#### 链接

.data段的对齐要求是一种优化，使得当程序执行时，目标文件中的段能够很有效率地传送到内存中（即以页的形式）

栈上的区域，从地址$2^{48}$开始，是为内核中的代码和数据保留的，内核即是操作系统驻留在内存中的部分

#### 进程状态

三态模型：运行、就绪、阻塞

五态模型：新建、运行、就绪、阻塞、终止

*终止态即zombie，这个状态作用在于允许其他进程（通常是创建进程的父进程）检查进程的返回代码，并查看刚刚完成的进程是否成功执行）*

可中断的睡眠状态，不可中断的睡眠状态

#### IO多路复用（待续

###### select的限制

* 一个进程能打开的最大文件描述符是有限的，默认为1024
* 对fd进行扫描时是线性扫描，fd剧增后，IO效率降低，每次调用都对fd进行线性扫描遍历，随着fd的增加会造成遍历速度慢的问题。 

###### poll的限制

* 大量的fd数组被整体复制于内核态和用户态之间，而不管这样的复制是不是有意义。 
* 同select相同的是调用结束后需要轮询来获取就绪描述符。

###### epoll

epoll使用一组函数来完成任务，而不是单个函数。其次，epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中，从而无需像select和poll那样每次调用都要重复传入文件描述符集或事件集。

#### 阻塞非阻塞&同步异步

在进程通信层面，这两对基本是同义词

同步和异步关注的是**消息通信机制**：

* 同步是有一次请求返回一次请求
* 异步可以向同一个对象多次传递请求

阻塞和非阻塞关注的是**程序在等待调用结果时的状态**：

* 阻塞是指调用者一直等待，直到被调用的对象返回结果
* 非阻塞是是调用后直接返回，被调用者准备好后通知调用者处理

#### 进程(CPU)调度算法

1. FCFS(先到先服务)

2. SJF(最短作业优先)

    最佳调度算法，对于给定的一组进程，平均等待时间最小。但无法知道下一个CPU区间的长度

3. 优先级调度(starvation)->(aging)(随时间提高优先级)

4. RR(轮转法调度)

5. 多级队列调度(starvation)

6. 多级反馈队列

#### 可重入

在运行某个函数或者代码时因为某个原因（中断或者抢占资源问题）而中止函数或代码的运行，等到问题解决后，重新进入该函数或者代码继续运行。其结果不会受到影响（和没有被打断时，运行结果一样）。那么这个函数或者代码就称为可重入的。