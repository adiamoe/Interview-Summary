# 操作系统

#### [缺页中断](https://www.cnblogs.com/sunsky303/p/9214223.html)

软件试图访问已映射在虚拟地址空间中，但是目前并未被加载在物理内存中的一个分页时，由中央处理器的内存管理单元所发出的中断。

#### [进程间的通信方式](https://blog.csdn.net/m0_37907797/article/details/103188294)

1. 管道

    单向传输，类似于缓存。一个进程把数据放在某个缓存区域，然后等待另一个进程读取。

    缺点：效率低下，a进程给b进程传递数据，只有等待b进程读取数据之后a进程才能返回。

    分为：

    * 匿名管道
    * 命名管道

2. 消息队列

    无需等待，可直接返回。但如果通信频繁或者数据较多，拷贝和读取内存会降低性能

3. 共享内存

    因为分配给进程的空间是虚拟内存地址，因此可以将部分虚拟内存映射到同一块物理内存，进行内存共享。避免了频繁拷贝。

4. 信号量

5. Socket

6. 信号：见下文

#### 线程的6种状态

1. New
2. Runnable(分为Running和Ready)
3. Blocked(**进入 synchronized 关键字保护的代码，但是没有获取到 monitor 锁**)
4. Waiting
5. Timed Waiting
6. Terminated

**处于 Runnable 状态的线程并不一定在运行**。

**Blocked 在等待其他线程释放 monitor 锁，而 Waiting 则是在等待某个条件，比如 join 的线程执行完毕，或者是 notify ()/notifyAll ()**。

Timed Waiting与 Waiting 状态的区别在于：**有没有时间限制，Timed Waiting 会等待超时，由系统自动唤醒，或者在超时前被唤醒信号唤醒**。

#### 进程和线程有什么区别

1. 进程是内存分配的最小单位，线程是调度的最小单位

2. 进程有自己的独立地址空间，而线程则是共享本线程的数据空间。因此CPU切换和创建一个线程的花费远小于进程

3. 进程切换比线程切换慢的原因在于，进程切换后地址空间发生改变，会导致TLB失效，需要从页表中读取数据使得程序运行缓慢

    *优化方案是： 增加硬件支持，实现跨上下文切换的TLB共享， 例如在TLB表项中添加进程标识符，区分不同进程*

#### 进程状态

三态模型：运行、就绪、阻塞

五态模型：新建、运行、就绪、阻塞、终止

终止态即zombie，这个状态作用在于允许其他进程（通常是创建进程的父进程）检查进程的返回代码，并查看刚刚完成的进程是否成功执行）

可中断的睡眠状态，不可中断的睡眠状态

#### [IO多路复用](https://www.jianshu.com/p/397449cadc9a)

在一个线程内处理多个socket的请求，当有I/O发生的时候，select遍历fd_set，找到就绪的fd进行读写。

###### select的限制

* 一个进程能打开的最大文件描述符是有限的，默认为1024
* 对fd进行扫描时是线性扫描，fd剧增后，IO效率降低，每次调用都对fd进行线性扫描遍历，随着fd的增加会造成遍历速度慢的问题。 

###### poll的限制

* 大量的fd数组被整体复制于内核态和用户态之间，而不管这样的复制是不是有意义。 
* 同select相同的是调用结束后需要轮询来获取就绪描述符。

###### epoll

没有最大并发的限制，epoll使用一组函数来完成任务，而不是单个函数。其次，epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中，从而无需像select和poll那样每次调用都要重复传入文件描述符集或事件集。

#### 阻塞非阻塞&同步异步

操作系统中的异常也分为同步异步：

异步异常是由处理器外部的I/O设备中的事件产生的，同步异常是执行一条指令的直接产物，如除零和缺页。

在进程通信层面，这两对基本是同义词

**区别：**

同步和异步关注的是**消息通信机制**：

* 同步是有一次请求返回一次请求
* 异步可以向同一个对象多次传递请求

阻塞和非阻塞关注的是**程序在等待调用结果时的状态**：

* 阻塞是指调用者一直等待，直到被调用的对象返回结果
* 非阻塞是是调用后直接返回，被调用者准备好后通知调用者处理

#### 进程(CPU)调度算法

1. FCFS(先到先服务)

2. SJF(最短作业优先)

    最佳调度算法，对于给定的一组进程，平均等待时间最小。但无法知道下一个CPU区间的长度

3. 优先级调度(starvation)->(aging)(随时间提高优先级)

4. RR(轮转法调度)

5. 多级队列调度(starvation)

    将不同进程根据内存大小、优先级、进程类型，永久地分配到某个队列，每个队列有自己地调度算法。队列之间的调度通常采用固定优先级抢占调度，或者划分时间片，对顶层队列分配更多的cpu时间。

    优点：低调度开销 缺点：不够灵活

6. 多级反馈队列

    允许进程在队列之间移动，如果进程占用过多cpu时间，就转移到优先级更低的队列（这种方案将I/O和交互进程留在更高级队列），在较低优先级队列中等待过长的进程会被转移到更高优先级，防止饥饿的发生。

#### 可重入

在运行某个函数或者代码时因为某个原因（中断或者抢占资源问题）而中止函数或代码的运行，等到问题解决后，重新进入该函数或者代码继续运行。其结果不会受到影响（和没有被打断时，运行结果一样）。那么这个函数或者代码就称为可重入的。

#### 链接

.data段的对齐要求是一种优化，使得当程序执行时，目标文件中的段能够很有效率地传送到内存中（即以页的形式）

栈上的区域，从地址$2^{48}$开始，是为内核中的代码和数据保留的，内核即是操作系统驻留在内存中的部分

#### [静态动态链接的区别](https://blog.csdn.net/kang___xi/article/details/80210717)

静态链接：以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。

但是存在问题是每次链接是以整个目标文件为单位，每个可执行文件都包含一份目标函数的副本，浪费内存空间。同时，对于任何标准函数的改变都要求重新编译整个源文件，使得标准函数的开发和维护变得很复杂。

动态链接使用共享库解决了这个问题，对任何给定的文件系统中，对于一个库只有一个.so文件，所有引用该库的可执行文件共享.so文件中的代码和数据。在内存中，一个共享库的.text节的一个副本可以被不同正在运行的进程共享，在可执行文件运行时通过动态链接器完成链接。

位置无关代码：可以加载而无需重定位的代码，用于实现共享库。

#### 信号

内核通过更新目的进程上下文的某个状态，发送一个信号给目的进程。可能由两种原因：

1. 内核检测到一个系统事件，如除零错误或子进程终止
2. 一个进程调用了kill函数显式地要求内核发送一个信号给目的进程

进程可以忽略这个信号，也可以终止或者执行信号处理程序捕获这个信号。在任何时刻，一种类型最多只会有一个待处理信号，**多的信号不会排队等待只会直接丢弃。**（因此每次接受信号时要处理尽可能多的信号。进程可以选择性的阻塞某种信号。

#### 文件系统

在linux系统中一切都可以看做是文件。一个进程要求内核打开相应的文件，内核返回一个小的非负整数，称为文件描述符。每个进程在开始时都有三个打开的文件，标准输入(0)，标准输出(1)和标准错误(2)。

每个进程有独立的描述符表，指向**文件表**中的一个表项。

**文件表**：内核对所有打开的文件维护一张文件表，所有进程共享这张表。每个文件的表项包括

1. 当前文件偏移量
2. 引用计数
3. 一个指向i-node表中表项的指针
4. 打开文件时所使用的的状态标识
5. ……

关闭一个描述符会减少相应的引用计数，当引用计数为0时内核删除该文件表表项。

独立的进程各自打开同一个文件，会在文件表中生成两个文件表项，各自拥有独立的偏移量和状态。不同文件描述符也能共享同一个文件表项。

**i-node表**

所有进程共享i-node表，inode保存给定文件的元数据。每个inode都由一个数字(inumber)隐式引用，操作系统用inumber来识别不同文件。inode通过多级文件索引指向数据块。

> 在每个inode中，实际上是所有关于文件的信息：文件类型（例如，常规文件、目录等）、大小、分配给它的块数、保护信息（如谁拥有该文件以及谁可以访问它）、一些时间信息（包括文件创建、修改或上次访问的时间文件下），以及有关其数据块驻留在磁盘上的位置的信息（如某种类型的指针）。我们将所有关于文件的信息称为元数据（metadata）

![文件系统](https://github.com/adiamoe/Interview-Summary/blob/master/FileSystem.png)

**目录**

目录也是一种文件，同样拥有inode和数据块，但永远不能直接写入目录。因为目录的格式被视为文件系统的元数据，因此只能间接更新目录。通过这种方式，文件系统可以确保目录的内容始终符合预期。目录最主要包括条目名称（也即文件名）和inumber，每个目录有两个额外的条目：.（点）和..（点点），即当前目录和父目录。

**位图**

位图是管理空闲空间的一种办法，记录inode和数据块中哪些是空闲的，哪些不是。

**硬链接**

文件名是对文件inumber的一个链接，在删除文件时，只会删除文件名和inumber之间的链接，并减少引用计数，当引用计数为0时才会释放inode和相关数据块，从而真正删除该文件。

**软链接（符号链接）**

硬链接不能创建目录的硬链接，因为可能会创造一个环使得部分内存永远不被释放。符号链接本身也是一个文件，将指向的文件路径作为数据。软链接不会增加引用计数，因此可能造成悬空引用。

**超级块**

文件系统中还有一个super block(超级块)，用于记录整个文件系统的整体信息，包括 inode 和 block 的总量、已经使用量和剩余量，以及文件系统的格式和相关信息等。

**打开文件**

读取文件时，需要从根目录沿着路径名因此读取inode和数据块，因此对于大型目录需要读取很多数据块。现代操作系统通过**动态划分**，从内存中动态地划分虚拟内存和文件系统缓存，减少读取磁盘。

##### 崩溃一致性

在每次更新文件时，需要同时写入三个块：位图，inode和数据块。理想的做法是atomically填写三个数据，但磁盘一次只提交一次写入，在这些更新之间可能会发生崩溃或断电。导致三个部分结果不一致。

**fsck**

扫描文件系统中的超级块、位图、inode中的数据，对不一致的情况执行相应的处理。如果位图和inode不一致，则信任inode内的信息。如果inode存在无效字段且不易修复，fsck会清除该inode和相应的位图。

缺点： 太慢，需要扫描整个磁盘。只有少数文件需要检查的情况下，扫描整个磁盘过于昂贵。

**日志**

在更新磁盘前，先将要做的事情写入日志。

1. 日志写入：将事务（包括事务开始块，所有即将写入的数据和元数据以及事务结束块）写入日志，等待写入完成
2. 将待处理的元数据和数据更新写入文件系统的最终位置。

但在写日志期间也可能发生崩溃，我们希望五个块（事务开始块，位图，inode，数据块，事务结束块）按顺序写入。然而:

> 给定如此大的写入，磁盘内部可以执行调度并以任何顺序完成大批写入的小块。因此，磁盘内部可以写入TxB、I[v2]、B[v2]和TxE，然后才写入Db。

* 因此有一种解决方案是：将事务写入日志时，在开始和结束块中包含日志内容的校验和。这样做可以使文件系统立即写入整个事务，而不会产生等待。如果在恢复期间，文件系统发现计算的校验和与事务中存储的校验和不匹配，则可以断定在写入事务期间发生了崩溃，从而丢弃文件系统更新。

比较简单的解决方案是分两步发出事务写入，先将出TxE块之外的所有块写入日志，当这些写入完成时，再写入TxE。

同时，磁盘保证任何512字节的写入都是原子的。更新后的文件系统协议如下：

1. 日志写入
2. 日志提交
3. 加检查点

日志的大小有限，当日志接近满时，不能向磁盘提交进一步的事务。因此日志文件系统将日志视为循环数据结构，一旦事务被加检查点，文件系统应释放它在日志中占用的空间，允许重用日志空间。有很多方法可以达到这个目的。例如，你只需在**日志超级块**（journal superblock）中标记日志中最旧和最新的事务。

然而将每个数据块写入磁盘两次，是沉重的成本，而崩溃则是一件罕见的事情，因此可以寻找更好的办法。

**元数据日志**

不将数据写入日志，仅写入元数据。提前将数据写入磁盘避免发生崩溃后inode指向无效数据。

1. 数据写入
将数据写入最终位置，等待完成（等待是可选的，详见下文）。
2. 日志元数据写入
将开始块和元数据写入日志，等待写入完成。
3. 日志提交
将事务提交块（包括TxE）写入日志，等待写完成，现在认为事务（包括数据）已提交（committed）。
4. 加检查点元数据
将元数据更新的内容写入文件系统中的最终位置。
5. 释放
稍后，在日志超级块中将事务标记为空闲。

在元数据日志中需要添加撤销记录，以避免删除目录时的inode重用问题（目录也是元数据）。

> 到目前为止，我们已经描述了保持文件系统元数据一致性的两个可选方法：基于fsck的偷懒方法，以及称为日志的更活跃的方法。但是，并不是只有这两种方法。Ganger和Patt引入了一种称为软更新[GP94]的方法。这种方法仔细地对文件系统的所有写入排序，以确保磁盘上的结构永远不会处于不一致的状态。例如，通过先写入指向的数据块，再写入指向它的inode，可以确保inode永远不会指向垃圾。对文件系统的所有结构可以导出类似的规则。然而，实现软更新可能是一个挑战。上述日志层的实现只需要具体文件系统结构的较少知识，但软更新需要每个文件系统数据结构的复杂知识，因此给系统增加了相当大的复杂性。
>
> 另一种方法称为写时复制（Copy-On-Write，COW），并且在许多流行的文件系统中使用，包括Sun的ZFS [B07]。这种技术永远不会覆写文件或目录。相反，它会对磁盘上以前未使用的位置进行新的更新。在完成许多更新后，COW文件系统会翻转文件系统的根结构，以包含指向刚更新结构的指针。这样做可以使文件系统保持一致。在将来的章节中讨论日志结构文件系统（LFS）时，我们将学习更多关于这种技术的知识。LFS是COW的早期范例。
>
> 另一种方法是我们刚刚在威斯康星大学开发的方法。这种技术名为基于反向指针的一致性（Backpointer-Based Consistency，BBC），它在写入之间不强制执行排序。为了实现一致性，系统中的每个块都会添加一个额外的反向指针。例如，每个数据块都引用它所属的inode。访问文件时，文件系统可以检查正向指针（inode或直接块中的地址）是否指向引用它的块，从而确定文件是否一致。如果是这样，一切都肯定安全地到达磁盘，因此文件是一致的。如果不是，则文件不一致，并返回错误。通过向文件系统添加反向指针，可以获得一种新形式的惰性崩溃一致性。
>
> 最后，我们还探索了减少日志协议等待磁盘写入完成的次数的技术。这种新方法名为乐观崩溃一致性（optimistic crash consistency），尽可能多地向磁盘发出写入，并利用事务校验和（transaction checksum）的一般形式，以及其他一些技术来检测不一致，如果出现不一致的话。对于某些工作负载，这些乐观技术可以将性能提高一个数量级。但是，要真正运行良好，需要稍微不同的磁盘接口。

##### 日志结构文件系统(LFS)

开发动机：

1. 内存大小不断增长，读取将在缓存中处理，因此文件系统的性能很大程度上取决于写入性能。
2. 随机I/O性能与顺序I/O性能之间存在巨大差距。如果能以顺序方式使用磁盘，就可以获得巨大的性能优势
3. 现有文件系统表现不佳且文件系统不支持RAID

因此理想的文件系统会专注于写入性能，并尝试利用磁盘的顺序带宽。因此引入日志结构文件系统(Log-structured File System  LFS)。

写入磁盘时，LFS首先将所有更新（包括元数据）缓冲在内存段，当段已满时，在一次长时间的顺序传输中写入磁盘，传输到磁盘的未使用部分。LFS永远不会覆写现有数据，而是始终将段写入空闲空间。

因为inode分散在磁盘上，LFS通过inode映射(imap)，在inumber和inode之间引入间接层，通过inumber可以指向最新版本的inode的磁盘地址。每次将inode写入磁盘时，imap都会使用其新位置进行更新。

LFS在磁盘上有固定的位置称为检查点区域(CR)，指向最新的imap，每次读取文件时，先通过CR将imap存入内存，查找对应的inode。

**垃圾清理**

LFS会为描述每个块的每个段添加一些额外信息。具体地说，对于每个数据块D，LFS包括其inumber（它属于哪个文件）及其偏移量（这是该文件的哪一块）。该信息记录在一个数据结构中，位于段头部，称为段摘要块（segment summary block）。通过检查inumber对应的inode指向的位置是否是该数据块即可确定该块的死活。

**崩溃恢复和日志**

待续